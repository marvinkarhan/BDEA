Prompt: U are a professor creating a tutorial using jupiter notebook analyzing data. You have to write data in the given dataset. The description of the assignment is: Erstellen Sie ein Notebook-basiertes Tutorial, in dem Sie eine beliebige Datenbank (SQL oder NoSQL (außer Postgres)) in einem Docker-Container ausführen und einen beliebigen Daten-Import mit einer beispielhaften Datenanalyse zeigen (!= dem Bsp. aus der Vorlesung). Seien Sie gerne kreativ.

Die Datenanalyse soll dabei interaktiv in Form von Notebooks demonstriert werden (entweder Apache Zeppelin oder JupyterLab). Verwenden sie geeignete Visualisierungsmöglichkeiten (Analysefunktionen zur Aggregation, Tabellen und Plots) um ihre gewonnenen Daten übersichtlich zu veranschaulichen. Fügen Sie für ihre Analyseschritte jeweils geeignete Beschreibungen hinzu damit diese nachvollziehbar sind.

Das Tutorial soll zwischen 10 und 15 min „dauern“ (d.h. Lesedauer) und hat als Zielgruppe Ihre Mitstudierenden aus der Veranstaltung, die auf dieser Basis in der Lage sein sollen, die Analyse nachzuvollziehen.

Bitte geben Sie (1) alle verwendeten Quellen zu Ihrem Tutorial nach guter wissenschaftlicher Praxis in einer begleitenden PDF-Datei an, und (2) geben Sie die verwendeten Notebooks die alle demonstrierten Anfragen enthalten ab. Dritte sollten in der Lage sein ihr Tutorial lokal auszuführen.

Optional (!): Wenn sie möchten, können Sie gerne ein entsprechendes Video Tutorial anfertigen.

Bewertet werden vor allem Kreativität der Aufgabe, Sorgfalt und didaktischer Aufbau bzw. Nachvollziehbarkeit.

Einige Ideen für mögliche Daten (werden Sie gerne selbst kreativ):

•Opendata der Stadt Mannheim
•Kaggle.com Data Science Challenges
•Daten zu Spielen der Fußball-Bundesliga
•Amazon Movie Reviews
•„Awesome“ Data Set Lists in GitHub etc.
the data set you should use is descibed here: 
About Dataset
Amazon Prime Video - TV Shows and Movies
This dataset was created to list all shows and movies available on Amazon Prime. It was collected from JustWatch in March 2023, containing data available in the United States.

Content
This dataset contains two files, one for the titles (titles.csv) and the other for the cast (credits.csv) of each movie and show on the platform.

The titles.csv contains more than 10k titles, witch 15 columns containing:

id: The title ID on JustWatch.
title: The name of the title.
show_type: TV show or movie.
description: A brief description.
release_year: The release year.
age_certification: The age certification.
runtime: The length of the episode (SHOW) or movie.
genres: A list of genres.
production_countries: A list of countries that - produced the title.
seasons: Number of seasons if it's a SHOW.
imdb_id: The title ID on IMDB.
imdb_score: Score on IMDB.
imdb_votes: Votes on IMDB.
tmdb_popularity: Popularity on TMDB.
tmdb_score: Score on TMDB.
The credits.csv contains over 140k credits of actors and directors, with 5 columns containing:

person_ID: The person ID on JustWatch.
id: The title ID on JustWatch.
name: The actor or director's name.
character_name: The character name.
role: ACTOR or DIRECTOR.


Amazon Prime Video Data Analysis Tutorial
In diesem Tutorial werden wir ein Jupyter Notebook verwenden, um eine Datenanalyse des Amazon Prime Video-Datensatzes durchzuführen. Wir werden eine SQL-Datenbank in einem Docker-Container ausführen, um unsere Daten zu importieren und zu analysieren. Die Visualisierung wird durch geeignete Plots und Tabellen unterstützt.

Voraussetzungen
Stellen Sie sicher, dass Sie Docker und JupyterLab oder Jupyter Notebook auf Ihrem Computer installiert haben.

1. Docker-Container erstellen
Zuerst erstellen wir einen Docker-Container, um eine MySQL-Datenbank auszuführen. Erstellen Sie eine docker-compose.yml Datei mit dem folgenden Inhalt:

yaml
Copy code
version: "3.9"
services:
  db:
    image: mysql:8.0
    container_name: amazon_prime_db
    environment:
      MYSQL_ROOT_PASSWORD: mysecretpassword
    volumes:
      - ./data:/docker-entrypoint-initdb.d
    ports:
      - "3306:3306"
Führen Sie dann docker-compose up -d aus, um den Container zu erstellen und zu starten. Die MySQL-Datenbank wird auf Port 3306 laufen.

2. Datenbank erstellen und Datensätze importieren
Erstellen Sie zunächst eine neue Datenbank in Ihrem MySQL-Container und erstellen Sie die Tabellen, die wir benötigen:

sql
Copy code
CREATE DATABASE amazon_prime;
USE amazon_prime;

CREATE TABLE titles (
  id INT PRIMARY KEY,
  title VARCHAR(255),
  show_type VARCHAR(255),
  description TEXT,
  release_year INT,
  age_certification VARCHAR(255),
  runtime INT,
  genres VARCHAR(255),
  production_countries VARCHAR(255),
  seasons INT,
  imdb_id VARCHAR(255),
  imdb_score FLOAT,
  imdb_votes INT,
  tmdb_popularity FLOAT,
  tmdb_score FLOAT
);

CREATE TABLE credits (
  person_ID INT,
  id INT,
  name VARCHAR(255),
  character_name VARCHAR(255),
  role VARCHAR(255),
  FOREIGN KEY (id) REFERENCES titles(id)
);
Importieren Sie die Daten aus den CSV-Dateien in die entsprechenden Tabellen:

sql
Copy code
LOAD DATA INFILE '/docker-entrypoint-initdb.d/titles.csv'
INTO TABLE titles
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS;

LOAD DATA INFILE '/docker-entrypoint-initdb.d/credits.csv'
INTO TABLE credits
FIELDS TERMINATED BY ','
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
IGNORE 1 ROWS;
3. Jupyter Notebook erstellen
Erstellen Sie ein neues Jupyter Notebook und importieren Sie die erforderlichen Bibliotheken:

python
Copy code
import pandas as pd
import mysql.connector
import matplotlib.pyplot as plt
import seaborn as sns
Stellen Sie eine Verbindung zur MySQL-Datenbank her:

python
Copy code
connection = mysql.connector.connect(
    host="localhost",
    user="root",
    password="mysecretpassword",
    database="amazon_prime"
)
4. Datenanalyse
Führen Sie jetzt SQL-Anfragen aus, um die Daten zu analysieren und visualisieren Sie die Ergebnisse mithilfe von Plots und Tabellen.

4.1 Beliebtesten Genres
python
Copy code
sql_query = """
SELECT genres, COUNT(*) as count
FROM titles
GROUP BY genres
ORDER BY count DESC
LIMIT 10;
"""

popular_genres = pd.read_sql_query(sql_query, connection)

Plot
plt.figure(figsize=(10, 5))
sns.barplot(x='genres', y='count', data=popular_genres)
plt.xticks(rotation=45)
plt.title("Top 10 Beliebteste Genres")
plt.show()

python
Copy code

### 4.2 Durchschnittliche IMDb-Bewertungen nach Altersfreigabe

```python
sql_query = """
SELECT age_certification, AVG(imdb_score) as avg_score
FROM titles
WHERE age_certification IS NOT NULL
GROUP BY age_certification
ORDER BY avg_score DESC;
"""

avg_rating_by_age = pd.read_sql_query(sql_query, connection)

# Plot
plt.figure(figsize=(10, 5))
sns.barplot(x='age_certification', y='avg_score', data=avg_rating_by_age)
plt.title("Durchschnittliche IMDb-Bewertungen nach Altersfreigabe")
plt.show()
4.3 Top 10 Schauspieler mit den meisten Credits
python
Copy code
sql_query = """
SELECT name, COUNT(*) as count
FROM credits
WHERE role = 'ACTOR'
GROUP BY name
ORDER BY count DESC
LIMIT 10;
"""

top_actors = pd.read_sql_query(sql_query, connection)

# Plot
plt.figure(figsize=(10, 5))
sns.barplot(x='name', y='count', data=top_actors)
plt.xticks(rotation=45)
plt.title("Top 10 Schauspieler mit den meisten Credits")
plt.show()
4.4 Top 10 Regisseure mit den meisten Credits
python
Copy code
sql_query = """
SELECT name, COUNT(*) as count
FROM credits
WHERE role = 'DIRECTOR'
GROUP BY name
ORDER BY count DESC
LIMIT 10;
"""

top_directors = pd.read_sql_query(sql_query, connection)

# Plot
plt.figure(figsize=(10, 5))
sns.barplot(x='name', y='count', data=top_directors)
plt.xticks(rotation=45)
plt.title("Top 10 Regisseure mit den meisten Credits")
plt.show()
5. Abschluss
In diesem Tutorial haben wir gelernt, wie man eine Datenanalyse in einem Jupyter Notebook durchführt, indem man eine SQL-Datenbank in einem Docker-Container verwendet. Wir haben Daten aus dem Amazon Prime Video-Datensatz analysiert und die Ergebnisse mithilfe von Plots und Tabellen visualisiert.

Denken Sie daran, alle verwendeten Quellen und das Jupyter Notebook in einer begleitenden PDF-Datei anzugeben, damit Dritte Ihr Tutorial lokal ausführen können.

Optional können Sie ein Video-Tutorial erstellen, um Ihre Analyse besser zu erklären und zu präsentieren.


Hier sind einige kreativere SQL-Abfragen, die Sie auf dem Amazon Prime Video-Datensatz ausführen können:

5.1 Top 5 Genres mit der höchsten durchschnittlichen IMDb-Bewertung
sql
Copy code
WITH genre_count AS (
  SELECT
    SUBSTRING_INDEX(SUBSTRING_INDEX(genres, ',', numbers.n), ',', -1) genre,
    imdb_score
  FROM
    titles
    JOIN
    (SELECT 1 n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) numbers
  ON
    CHAR_LENGTH(genres) - CHAR_LENGTH(REPLACE(genres, ',', '')) >= numbers.n - 1
)
SELECT
  genre,
  AVG(imdb_score) AS avg_imdb_score,
  COUNT(*) as count
FROM
  genre_count
GROUP BY
  genre
HAVING
  count > 100
ORDER BY
  avg_imdb_score DESC
LIMIT 5;
5.2 Top 10 Filme aus den 90er Jahren basierend auf IMDb-Bewertungen
sql
Copy code
SELECT
  title,
  release_year,
  imdb_score,
  imdb_votes
FROM
  titles
WHERE
  show_type = 'MOVIE' AND
  release_year BETWEEN 1990 AND 1999
ORDER BY
  imdb_score DESC,
  imdb_votes DESC
LIMIT 10;
5.3 Serien mit den meisten Staffeln
sql
Copy code
SELECT
  title,
  release_year,
  seasons
FROM
  titles
WHERE
  show_type = 'SHOW'
ORDER BY
  seasons DESC
LIMIT 10;
5.4 Beliebteste Schauspieler und Regisseure basierend auf der durchschnittlichen IMDb-Bewertung ihrer Titel
sql
Copy code
WITH credit_score AS (
  SELECT
    name,
    role,
    imdb_score
  FROM
    credits
    JOIN titles ON credits.id = titles.id
)
SELECT
  role,
  name,
  AVG(imdb_score) as avg_imdb_score,
  COUNT(*) as count
FROM
  credit_score
GROUP BY
  role, name
HAVING
  count > 5
ORDER BY
  avg_imdb_score DESC,
  count DESC
LIMIT 10;
5.5 Länder, die die meisten Filme produziert haben
sql
Copy code
WITH country_count AS (
  SELECT
    SUBSTRING_INDEX(SUBSTRING_INDEX(production_countries, ',', numbers.n), ',', -1) country
  FROM
    titles
    JOIN
    (SELECT 1 n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) numbers
  ON
    CHAR_LENGTH(production_countries) - CHAR_LENGTH(REPLACE(production_countries, ',', '')) >= numbers.n - 1
)
SELECT
  country,
  COUNT(*) as count
FROM
  country_count
GROUP BY
  country
ORDER BY
  count DESC
LIMIT 10;

create sql querries using analytic functions like lag, cume_dist or percentile_disc
Hier sind einige SQL-Abfragen, die Analysefunktionen wie LAG, CUME_DIST oder PERCENTILE_DISC verwenden:

6.1 Top 10 Filme mit dem größten Anstieg der IMDb-Bewertung im Vergleich zum vorherigen Jahr
sql
Copy code
WITH yearly_ratings AS (
  SELECT
    title,
    release_year,
    imdb_score,
    LAG(imdb_score) OVER (ORDER BY release_year) AS prev_year_imdb_score
  FROM
    titles
  WHERE
    show_type = 'MOVIE'
)
SELECT
  title,
  release_year,
  imdb_score,
  prev_year_imdb_score,
  (imdb_score - prev_year_imdb_score) AS score_difference
FROM
  yearly_ratings
WHERE
  prev_year_imdb_score IS NOT NULL
ORDER BY
  score_difference DESC
LIMIT 10;
6.2 Filme, die im oberen 10 % der IMDb-Bewertungen liegen
sql
Copy code
WITH score_percentiles AS (
  SELECT
    title,
    imdb_score,
    CUME_DIST() OVER (ORDER BY imdb_score DESC) AS score_percentile
  FROM
    titles
  WHERE
    show_type = 'MOVIE'
)
SELECT
  title,
  imdb_score
FROM
  score_percentiles
WHERE
  score_percentile <= 0.1
ORDER BY
  imdb_score DESC;
6.3 Median IMDb-Bewertung für jedes Genre
sql
Copy code
WITH genre_scores AS (
  SELECT
    SUBSTRING_INDEX(SUBSTRING_INDEX(genres, ',', numbers.n), ',', -1) genre,
    imdb_score
  FROM
    titles
    JOIN
    (SELECT 1 n UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4 UNION ALL SELECT 5) numbers
  ON
    CHAR_LENGTH(genres) - CHAR_LENGTH(REPLACE(genres, ',', '')) >= numbers.n - 1
)
SELECT
  genre,
  PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY imdb_score) AS median_imdb_score
FROM
  genre_scores
GROUP BY
  genre
ORDER BY
  median_imdb_score DESC;
6.4 Filme, deren Laufzeit unter dem 25. Perzentil liegt
sql
Copy code
WITH runtime_percentiles AS (
  SELECT
    title,
    runtime,
    PERCENTILE_DISC(0.25) WITHIN GROUP (ORDER BY runtime) OVER () AS runtime_25th_percentile
  FROM
    titles
  WHERE
    show_type = 'MOVIE'
)
SELECT
  title,
  runtime
FROM
  runtime_percentiles
WHERE
  runtime <= runtime_25th_percentile
ORDER BY
  runtime;
6.5 Top 5 Schauspieler mit den meisten Credits pro Jahr
sql
Copy code
WITH actor_credits AS (
  SELECT
    name,
    YEAR(cast.created_at) as year,
    COUNT(*) as credit_count
  FROM
    credits
    JOIN titles ON credits.id = titles.id
  WHERE
    role = 'ACTOR'
  GROUP BY
    name, year
)
SELECT
  year,
  name,
  credit_count,
  ROW_NUMBER() OVER (PARTITION BY year ORDER BY credit_count DESC) as ranking
FROM
  actor_credits
WHERE
  ranking <= 5
ORDER BY
  year, ranking;